# September 2024 OCapN Meeting

- **Chair:** Jonathan Rees
- **Scribe:** 
- **Present:**
  - Christine Lemmer-Webber (Spritely)
  - Mark Miller (Agoric)
  - Kris Kowal (Agoric)
  - Baldur (Independent)
  - Chip Morningstar (MetaMask)
  - David Thompson (Spritely)
  - Dimitris (MetaMask)
  - Erik Marks (MetaMask)
  - Saleh (MetaMask)
  - Ryan Peters (MetaMask)
  - Jessica Talon (Spritely)
  - kumavis (MetaMask)
  - Zachary Larson 
  - Jonathan Rees (Independent)
  - Juli (Spritely)

  ## Agenda

 - Closed issues - discussion only if there are objections
 - Calling Conventions https://github.com/ocapn/ocapn/issues/131
 - Review open issues:
   - IDL? #17
   - Terminology bikeshed: what to call vats-as-far-as-the-protocol-can-tell? #18
   - Backpressure? #20
   - Proposed captp protocol #24 and so on

## Minutes

### Closed Issues

Christine: There haven't been any spec-relevant closed issues for a while.

### Calling Conventions

https://github.com/ocapn/ocapn/issues/131

Kris: I've looked it over and we're in a good position to have a conversation

Jessica: This describes the Spritely and Agoric conventions. Last month we talked about strings vs. symbols/multiple operands/etc., and I also include a proposal here to "Continue with existing approach taken in current OCapN specification where methods are a convention of the first argument being a symbol [and] the handler/receiver may be implemented either as a function or an object with methods [and] if the sender/caller invokes a method and the handler/receiver is a function, the first argument will be conspicuously an OCapN symbol [and] if the sender/caller applies a function, passing an OCapN symbol as the first argument, and the receiver/handler is an object, the method with the corresponding string name will be invoked".

Kris: I want to come back to what to do in Haskell. But regardless, I think Agoric is prepared to agree to this, which for us means no longer supporting JavaScript Symbol.asyncIterator. Related, I have observed that registered symbols are problemetic for JavaScript, so OCapN symbols would most likely be objects, which will be awkward but mostly invisible to consumers because method names will be translated to strings. For OCapN, we will continue to have a single operator for invoking both functions and methods. But I would like to move for consensus on closing this issue.

Mark: If instances map in JavaScript to something other than the Symbol type, I think we would instead want a different term to avoid confusion. And I would propose "selector", which has some precedent in OO languages. Folding everything into just one kind of call is incompatible with the current shape of our eventual-send library, but I think Agoric can adapt. But it precludes a "function with methods" pattern that would otherwise be natural in E/JavaScript/etc. I want to make the costs on the Agoric side explicit before agreeing with Kris's position.

Christine: Jessica has been commenting in the chat and I'd like to hear more. Regarding the "selector" name, I'm comfortable but would hope for text explaining the mappings in languages such as Lisp.

Mark: To answer Jessica's question in chat, we would be renaming OCapN "symbol" to "selector" and would always be using that term even for non-initial operands.

Mark: JavaScript registered symbols in most if not all implementations are not garbage collectible and effectively constitute a permanent memory leak. I don't know if that's also the case for Lisp and Scheme implementations.

Christine: It sounds like everyone is fine with specifying symbols as reasonable mappings in various languages, so this works for me. The Lisps I have worked with (Guile and Racket) do GC symbols.

Jessica: I'm also happy with the "selector" name... it's a little confusing but not overly so. We should document abstract types at the top of the specification anyway.

Jonathan: In my implementations, symbols are garbage-collectible but IIRC it wasn't automatic. They're like weak pointers, and require a separate pass over the heap and somewhat more expensive as a result.

Kris: Things will be weird at the JS boundary, but I'm fine with that. Likewise Syrup and Preserves. If there's a resolution to change it, I volunteer to update the abstract types documentation.

Christine: What about the name "sym"?

Mark: I don't hate it. It's sufficiently different from "symbol" to avoid confusion in JS, although I still prefer "selector".

Christine: I bring it up for the historical connection, but also because it's a bit weird to allow "selector" after the first position. I don't really want to advocate for "atom" or [courtesy Baldur] "quark".

Jonathan: Let's vote in chat.

Christine: W3C conventions; +0/-0 express non-blocking preferences, +1/-1 express strong (possibly blocking) preferences.

Mark: I'm changing my vote... in the expected *intersection* across languages, given that this doesn't correspond to anything in non-initial position for at least JS, these are not likely to be used for anything other than method selection.

#### Type Naming Results

```
| Name           | Sym | Selector |
|----------------+-----+----------|
| Mark Miller    |  -0 |       +1 |
| Kris Kowal     |   0 |        0 |
| Baldur         |   0 |       +1 |
| Zachary Larson |  +1 |       +0 |
| Christine L-W  |  +1 |        0 |
| Juli           |  +1 |       -0 |
| David Thompson |  +1 |       -0 |
| Jonathan Rees  |   0 |       +1 |
| Jessica Tallon |  +0 |        0 |
| Erik Marks     |  -1 |       +1 |
```

```
Selector:
 +1: 4
 +0: 1
  0: 0
 -0: 2
 -1: 0
 
Sym:
 +1: 4
 +0: 1
  0: 3
 -0: 1
 -1: 1
```

Selector wins having no `-1`s

#### Back to the issue

Kris: I move for acceptance.

Mark: Second.

Christine: Second.

Christine: Clarification: it is still acceptable to pass selectors outside of first position.

Kris: Correct.

Christine: PROPOSAL: That we accept the current OCapN convention of having Selectors (formerly named "Symbols") be a convention corresponding to method invocation, with it still being acceptable to pass selectors outside the first position of an object invocation.

Jonathan: Without opposition, ACCEPTED: That we accept the current OCapN convention of having Selectors (formerly named "Symbols") be a convention corresponding to method invocation, with it still being acceptable to pass selectors outside the first position of an object invocation.

### Should we adopt IDL?

https://github.com/ocapn/ocapn/issues/17

Jessica: I'm generally opposed, but interested in other viewpoints.

Mark: Users of OCapN are still free to use IDL for organizing their own systems, but OCapN itself is more dynamic than is generally a good fit.

Kris: I would frame this as a decision not to pursue the design of an OCapN IDL and to commit to a lack of _requirement_ for an IDL.

Kris: I volunteer to document this as closed without prejudice.

### What do we call a CapTP not-exactly-a-vat?

https://github.com/ocapn/ocapn/issues/18

Jessica: I wrote this without the "vat" model in mind; Goblins previously used "machine" but updated to "node".

Mark: I'm very much against "node" and don't really like "machine". What are the other candidates?

Jessica: "peer" has been suggested.

Kris: "interlocutor" ;)

Mark: I like "peer". It supports the story about this being a peer-to-peer computing platform. The problem with "node" is that it's _so_ generic.

Jonathan: Absent objections, "peer" it is.

### Adjournment

Christine: I can scribe next time.