# October 2025 OCapN pre-standardization meeting, 2025-10-14

## Attendees
- **Chair**: Jonathan Rees
- **Scribe**: David Thompson
- **Present**:

- Kris Kowal (Agoric)
- David Thompson (Spritely)
- Christine Lemmer-Webber (Spritely)
- Baldur (Independent)
- Chip Morningstar
- Jessica Tallon (Spritely)
- Jonathan Rees (Independent)
- Juliana Sims (Spritely)
- kumavis (Metamask)
- Mark Miller (Agoric)
- Richard Gibson (Agoric)
- Ridley (Independent)

# Minutes

## [#62](https://github.com/ocapn/ocapn/issues/62) bootstrap object

Kris: There are two implicit layers of captp that we should make explicit. There should be an explicit 2-party ocapn where the bootstrap object can be anything and then a 3-party ocapn where the bootstrap object has to be a nonce locator. An arbitrary object is fine a 2-party scenario and a 3-party scenario object is also a nonce locator and has the handoff gift methods. The nonce locator does not need to be extensible because it is inherently extensible by swiss num sturdyrefs.

MarkM: I don't understand that.

Kris: As specified the nonce locator is extensible via swiss num, you can get additional capability via fetch for a swiss num.

MarkM: In the two party case, are swiss nums specified?

Kris: As I envision it, no.

MarkM: Good. The 3 party online handoff in E was clist based with handoff tables. Kumavis and I had a conversation that the 3-party scenario with swiss nums has memory leak issues. A clist based handoff approach allows for GC. The place where E still relied on swiss nums was the case of offline capabilities and translating to online capabilities. The sturdyref to live ref transition. For just online handoff, I think we can and should avoid swissnums.

Kris: To be clear my understanding is that swiss nums are only used for handoffs.

Baldur: IIUI in OCapN, there are no sturdyref used in handoffs. It's the session key with the gift and authentication of the party receiving the gift. What I want for the nonce locator bootstrap object is the possibility of extension via methods that are yet to be defined such as certificate-based delegation. That way if you're implementing OCapN you don't have to implement the whole thing in one go.

Jessica: For clarification, currently the bootstrap object has 3 methods. The first is a fetch of a swiss num for sturdyrefs and are used to bootstrap connections and a good way of out-of-band bootstrapping. Then there are two handoff related methods. The handoffs are certificate based. The actual handoff tables are one for depositing and one for withdrawing gifts. The handoffs are session based, tied to a specific session and not global. They contain a mapping from gift id to an object. The rest of the 3ph machinery is entirely certificate based. One that the gifter creates and then the receiver augments it and sends it to the <missed spec terminology>. I think this issue around whether methods are conventions or requirements, whether we're swapping those out for operators, and then Kris mentioned that if you're doing 2 party then you don't need to gift methods. I think that all nodes should support 3ph. Changing that in the spec and the implementation guide and test guide would require some thought. I suggest we push these concerns into its own issue so we can consider it separately.

Kris: I agree with that. I am in favor of the bootstrap object being a target that receives method calls rather than operations.

JAR: Next step is for Kris to add some information to the issue?

Kris: Ideally the next step is to close the issue as resolved that we will continue with using an object-based protocol for the bootstrap object nonce locator protocol.

JAR: Sounds like a well formed resolution.

Baldur: I'm against dropping the nonce locator bootstrap object.

Kris: Are you saying in favor of closing this issue in favor of an object-based protocol?

Baldur: Yes.

Kris: Thank you.

Christine: I'm voicing to basically say "yes" and add that's it good for another reason. One thing that's valuable about using the object protocol we are already specifying is that we are reducing the number of operations that are required to implement OCapN.

Kris: No objects, so I will close this issue and open new issues for the orthogonal concerns.

JAR: Very good. How much time should we reserve for Mark's new business? 10 minutes? 20 minutes?

Kris: Dave doesn't want to spend a lot of time on it.  Mark?

MarkM: I don't expect to resolve very much with 10-20 minutes but I don't expect to resolve much anyway. I want to get the topic started and what I expect to be the controversial points so we can have them jointly in front of us.

Kris: I'd like to reserve at least 10 minutes to discuss perimeter types.

JAR: Well that's all we'd have time for. Are we okay skipping over all the other old and new business?  I take that silence for a yes.

## [#182](https://github.com/ocapn/ocapn/issues/183) Perimeter types

Jessica: I'll introduce this topic and I hope we can come to a resolution quickly. This issue is perimeter types / protocol extensions. How do you handle types that are not in the base set of types that we handle? Goblins has quite a few like in-based OCapN IDs, Scheme vectors and pairs. We use the tagged data structure but we also expose it to users so they can tag their own data and send it over the wire. For Goblins, tagged data types that are from the user, we wrap them in a "user tag" tags so they don't get mixed up for our internal tagged types. This effectively creates two different namespaces, one for OCapN types and one for userspace. Should we have these two different namespaces or is it intended that there's just one? This factors into things like `on:untag`.

Kris: My position on this is that OCapN itself should only have one kind of tagging. It is certainly possible in userspace for a particular implementation to partition the tags between escaped and unescaped. I don't think that's wise. I think that hints at a lacking in the data model of the first class type. If there's a guarantee that we can round trip all tagged values then it's fine but that might be a tough standard to meet, though. In summary, OCapN should only have one type of tag that partitions the first class and second class values and specify that all tagged values round trip.

MarkM: I'm in agreement with Kris, but let me expand on that. Spritely has a bunch of tagged values that are recognized directly by Spritely that gives them a first-class status, but if Endo has its own set of tagged values that are distinct from Spritely's. If Spritely is talking through Endo and getting sent to something else that is Spritely then it's important that the tagged data gets preserved such that when Endo relays it back to Spritely that Spritely can recognize it and vice versa. In Endo, we're very careful about the layering so that at the layer of OCapN we do not know what those higher level data types are and at the high-level the thing that recognizes them still is just one of many possible recognition layers. <Dave lost connectivity momentarily and missed the rest>

Jessica: That helps for understanding the situation when the tag matches but the data does not.

Baldur: Encoding is like the medium of sound in spoken language. On top of that we have we have words, in this case we are talking about using tags as a word to delineate nouns. In the OCapN context you are talking about objects reachable from this connection. When you have user defined types like copy bags, we should still have the escape of "target <something>" so we could use a default for that particular escape tag.

MarkM: I wasn't able to parse some of what you said. The OCapN representation of tagged being a string tag plus a payload, are you suggesting something else?

Baldur: No, I'm suggesting we use double tags at the protocol level.

MarkM: From Endo's POV, all of the Spritely data types are user defined data types and vice versa.

Richard: I agree with Kris that there ought to be a protocol limitation that there's only one wrapping for a tagged value. I thought that Endo tried to eagerly interpret that uses a tag it knows about?

MarkM: The Endo marshall layer and the pass file layer don't have any knowledge of the interpretation of tags. If you are not on top of the Endo patterns layer then there is no interpretation of the tag. It's only the patterns layer that does that interpretation. Everything is built on the patterns layer so it seems like it's built-in but it's not. Things with familiar tag names but with payloads that do not satisfy the expected payload are passed through.

Richard: I thought that Endo unmarshall tried to unmarshall, say, a copy bag, would fail when it ran into something that didn't have the right payload.

MarkM: It's passed through.

Richard: We should specify that this data MUST pass through.

MarkM: The reason why the protocol already specifies it is because of the round-tripping constraints. A tagged must round trip as a tagged. A tag that was not locally recognized and threw an error would not round trip.

Richard: Whether it recognizes a tag or not must be irrelevant for this interaction pattern to hold.

MarkM: Yes.

Christine: I do think it's important to have round tripping. Mark you're right that there are certain things in our OCapN we deploy that are Spritely things, like vectors. The debate is that should the vector type move to the userspace types space.  A thing we could do is move things that are fairly Spritely specific into the userspace type tagging system.  We certainly can move those things into user defined types, but 1) how should it be laid out and 2) when we have an extension should it be an extension to the core protocol operators or is it an extension to user-defined types.

Kris: Round tripping is a proxy concern. Messages should be able to pass through an intermediary without a loss. We had a proxying system at Uber where information could be lost like this.

Richard: Pass through is table stakes. We must be able to do it. But also for convenient APIs the need to invent a data type should be minimized. We want Spritely and Endo to be able to communicate maps, vectors, etc. easily. Having an anemic set of data types in the protocol is probably a bad idea.

Kris: Christine, are all of the extended types that Spritely currently uses expressible in terms of tagged types?

Christine: They could be but they aren't at the moment. We could remove those special types and use the general purpose mechanism for user defined types that everything else already uses.

MarkM: I think we should be thinking in terms of layered standards. That's part of why I'm so attracted to things like tagged. The OCapN layer, by having the minimal set of basic types and then having the tagged escape, the thing you need the most universal agreement on is the smallest number of things, and the richer types can be separated from the agreement of the OCapN layer. It's okay if the agreement is arrived at by a smaller set of parties that have a need to use that particular type.  The more high-level the type is, the more it should be separated because the less it needs to be universal in order to be useful.

Richard: In HTTP everyone must agree on the syntax of messages. How do you identify the content as distinct from the header? If you are on the open internet and pass a header that is in the registry then you have given up the right to be surprised when the other side <missed the end of this>


## [Cap'n Web](https://github.com/cloudflare/capnweb)

MarkM: Cap'n Web is close enough to us that Kenton is somewhat open to adjusting Cap'n Web to accommodate our needs. From the Endo perspective, the leverage we get from better interop with Cap'n Web, assuming the costs are not overwhelming, is overwhelmingly larger than the leverage we get from interoperating with Spritely. The elephant of Cloudflare is so huge that if Cap'n Web is close that we should renegotiate some of the OcapN agreements. The two that stand out to me are -0 which Cap'n Web doesn't have and symbols. With symbols, it raises the question from the Spritely side that if OcapN drops symbols, could it accommodated by the tagged type? Since OCapN symbols are not compatible with JS symbols, it seems unlikely that Cap'n Web would be willing to add them.

JAR: What are the next steps on this?

Kris: We should file issues on these things.

Dave: I'm concerned that pursuing Cap'n Web compatibility threatens to derail OCapN.

Christine: It's overwhelming that we've been doing this work for 2 years and now this large pivot is being thrown at us.  We have asked the question if we could get Goblins to talk over Cap'n Web but idk. Cloudflare is the elephant in the room and we shouldn't ignore them but I don't know what else to say right now. We need to discover how much is Kenton interested in doing a conversations of things but these meetings have been here and he could have been participating. The way this is coming up is bumming me out, to be honest.

MarkM: I sympathize. Cap'n Web is an attractor in the same way that JS led to me dropping E, even though it was messier in so many ways.

Kris: To be clear, I don't think we are flushing OCapN down the toilet. I think it is ahead of Cap'n Web in a number of ways and convergence could happen over time.

Dave: Reason I heard about Cap'n web was from hackernews and lobsters. I made a comment on lobsters and Kenton responded something to the effect of they had looked at OCapN and thought it was vaporware. They didn't seem too interested back then?

Juli: So should we have bring Kenton into this meeting?

JAR: Should we file an issue?

Kris: Kumavis did a pretty in-depth analysis comparing OCapN and Cap'n Web.

Juli: To clarify my proposal is less about technical differences and more about willingness to collaborate at all.

Kris: Agreed.

MarkM: Agreed.

JAR: We are adjourned.
