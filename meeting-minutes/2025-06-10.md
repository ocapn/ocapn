# June 2025 OCapN pre-standardization meeting, 2025-06-10

- **Chair**: Jonathan Rees
- **Scribe**: Christine Lemmer-Webber
- **Present**:
  - Jessica Tallon (Spritely)
  - Christine Lemmber Webber (Spritely)
  - David Thompson (Spritely)
  - Baldur (Independent)
  - Dan Finlay
  - Erik Marks (MetaMask)
  - grypez (MetaMask)
  - Jonathan Rees (Independent)
  - Juliana Sims (Spritely)
  - Kris Kowal (Agoric)
  - Mark Miller (Agoric)
  - Richard Gibson (Agoric)
  - Ridley (Independent)


## Agenda

### Old business: Pull requests

- [#176](https://github.com/ocapn/ocapn/pull/176) Align anchors with Github generated anchors (anchors @kriskowal, awaiting @tsyesika review)
- [#171](https://github.com/ocapn/ocapn/pull/171) Add desc:import-answer (import-answer, awaiting @tsyesika review?)
- [#104](https://github.com/ocapn/ocapn/pull/104) Propose TCP Testing Netlayer #104 (TCP tessting netlayer @kriskowal)

### Revisit

- [#165](https://github.com/ocapn/ocapn/issues/165) Let’s rename Selector to Symbol (assign to @kriskowal?)
- [#62](https://github.com/ocapn/ocapn/issues/62) bootstrap object methods: requirement or convention? (needs a champion)
- [#167](https://github.com/ocapn/ocapn/issues/167) Proposal: Single op:deliver message type with resolution subscription via op:listen (@kumavis)

### New business
- Spritely game/demo (@davexunit)

# Minutes

Discussion of https://dustycloud.org/tmp/old-markm-original-e-notes/ being discovered of old E diagrams

## Spritely game/demo
David: Sharing game with the group:
https://davexunit.itch.io/goblinville

Then enter this capability (will not work post meeting):
ocapn://kjvy4q57mcjqowfjxskvjhwh5by6qmxwf6io4ebnbajdg23vxwpq.websocket/s/owTMxsorfhS2Yy-IY-w5y6OG88YzY9JSxFvLU5mSnWc?url=wss%3A%2F%2Fspritely.institute%3A8080
- select name
- select sprite

Z interacts/harvests crop
X uses the current item
This is all happening over OcapN! The most users that have ever been in this game.
Using Goblins and Hoot!

Was made in a hurry, and may not be "as ocappy" as Dave'd like, and was easy to convert from single player to multiplayer.

This does demonstrate *some* ocap semantics, in that after you create your player object, no one can forge messages to your character (the capability to the game allows creating characters, which are then uniquely endowed)

JAR: Aiming to review PRs, first one is aligning anchors PR, waiting review from Jessica

Jessica: I will get to it tomorrow

JAR: Also awaiting a jessica review for #171

Jessica: That one's a bit more involved, have to think about it more

JAR: Also a review for tcp netlayer

Jessica: Implemented in Goblins to take over test suite for CI. Probably gives us more confidence.

JAR: We'll wait for your changes. We can skip the other four for now.

Kris: Jessica will take over #104

JAR: Kris nominated three issues for discussion.

### [#165](https://github.com/ocapn/ocapn/issues/165) Let’s rename Selector to Symbol

Kris: I believe Mark & I are both content with the OcapN name for what we formerly called "Selector" to become "Symbol". We expect no objections. I'll then go on open an editorial PR to make that consistent.

Spritely does not object.

David humorously proposes spelling symbol "Cymbal". (ba-dum-ching!), but we're not sure how serious he was. Maybe very seriously.

JAR: Slippery slope for percussion instrument.

### [#62](https://github.com/ocapn/ocapn/issues/62) bootstrap object methods: requirement or convention?

Jessica: I hope I'm understanding correctly that this is about removing the usage of methods within the spec and replacing them with operators to make the layers more apparent/cleaner. Right?

Kris: Broad characterization. There are a few places we're using objects in the spec that could be messages in the spec: Bootstrap is one. Fulfill/reject are two more. I would like to consider these separate.

Jessica: I'll say we're ok with doing this, doing those together. I believe everyone at Spritely is ok with replacing those operators instead.

Kris: Then I propose (and I'm willing to do the work) to revise the spec to replace "resolve me desk" with concretely an "off-resolve" and "off-break". This is notably different from now: Currently the resolve-me target has two methods: fulfilled and break. I'm enthusiastic about turning that into messages.
  Break is uncontroversial. It's great in OcapN, and taking it off the object protocol is great since scheme & JS will inherently have different objects.
  Fulfill usually means to fully settle a value, and resolve in JS is the verb for any progress on the resolution of a promise, including the resolution dependent on fulfillment or rejection. There are options:
  - Keep fulfill as an operator & have {?} forward and {?} resolve. Fulfill would assert that the next state is in the fulfilled state, while forward would assert that the target was in the pending state, or at least referred to a promise. I don't have strong feelings on this: We should either have one method that does both fulfill & forward, or two methods that do and assert the state.
  I do have strong opinions that it should be (sunk into the protocol?) and left to this group.

  JAR: SGTM.

  Christine: Three things were raised here. One controversial for us but I think we handled it.

  1. Should we sink these into the protocol? We've come to accept that both the bootstrap object and on promise resolution we should have operators/descriptors/protocolified operations.
  2. What should be done about the names? I'm concerned... would like to handle fulfill/reject separately. Break is uncontroversial. I'm less sure that calling fulfill "resolve", or having three operations: That's the most worrying of all. The convention we all agree on here is when you (currently called) fulfill a promise, the promise hasn't settled, and will operate on forward messages. Are we adding a new possibility that you can fulfill it and it would permanently ... forward messages(??)

  MarkM: No. In protocol design (in tension with language design).

  Christine:
  The methods are:
  - Break
  - Fulfill

 Should those names change?

 MarkM: If forwarding one promise to another with a method named "fulfill", that will create horrible confusion, because we cannot refer to the resulting state of the promise that is fulfilled.

 Christine: Do you have a break in the name.. or should it be three?

 MarkM: In JS and E, we have break and resolve, where break is redundant: You can resolve to anything (if you resolve to another unsettled promise, then you forward, if you resolve to a broken promise, then this promise becomes similarly broken, and therefore the break operation is just essentially a shorthand for saying "resolve this to an equivalently broken promise").

 What we did in JS but should do the opposite for a protocol: Have three operations, none of which are named resolve:
1. Forward
2. Fulfill
3. Reject

I'm starting to talk myself out of it... but let me make the case.

As we did with the data lookup operations for the tags, where you have to provide the tag name, and if you provide a different name than the thing you're currently (untagged?) then it's an error.

The question is: To what degree should we make narrower intentions directly reflected in the operation and then obligate the receiver to do the implicit error check and reject the operation with an error if it violates assumptions?

That would argue for fwd- vs fulfilled vs- reject. I don't like that b/c sometimes the polymorphism is useful: You don't know what the other thing is, you just want to resolve this promise to whatever it is. That would argue for keeping resolve & break, and possibly adding an explicit fulfill, which is really just an assertion followed by a resolve.

Having talked that all out, I would recomend start with "resolve" and "Break", and see if "fulfill" is (necessary?).

Christine: JS and Scheme are doing the same thing but with different names, but in Scheme we're using a name that doesn't make sense in JS (resolve). The Spritely people think resolve makes sense to resolve instead of fulfill. So I propose we just go with two operations,a nd change "fulfill" to "resolve".

Kris: Agree.

MarkM: This doesn't change the protocol, but how we speak of it. We want to state the states of the promise, and I think there's been some confusion from E, in missing necessary distinction, and this is a good time to repair it. We've reparied it in JS but now we can in OcapN:

A promise can be unresolved or resolved. If resolved, it can be fwd'd or settled. If settled, it can be fulfilled or broken.

Kris: [sorry, missed a bit] ... Fulfilling to a promise is always nonsensical.

Jessica: Shall we discuss the bootstrap object methods?
Also, since this would remove all methods from the spec, we should at least keep a note on the convention of method calling, like a note for implementors, like "if implementing method calling maybe do this..."?

Kris: For bootstrap object, I'm not yet sure. It's reasonable to sink the methods of bootstrap into messages. The tension in my mind is that I suspect there are cases where one will spin up an OcapN session and use a target from another session as the implementation from the bootstrap. Like if in a process vat, and there's a machine-level multi-vat kernel within a single peer. To do 3-party handoff, it can't be done locally within the vat, we must appeal to the kernel, in which case there must be an OcapN session over a socket or something, where you'll want an object from the kernel that you could instantiate your session with.

MarkM: Hold on, there's no such thing as a file handle between machines.

Kris: I mean within vats on the same machine. A kernel with child vats, maybe separate processes. Would need to appeal to the kernel for the 3PHO.

Christine: This seems out of band of the netlayer, is a juicy topic we should not tackle today.

Kris: Agree.

Baldur: Was queued, agree to defer.

Kris: I'm sure we can make progress either way: One of the reasons I was originally confused/hesitant about the bootstrap protocol is that in endo it means "a public facet that anyone has access to on connection", which is not the same thing for 3PHO. Talking to Kumavis, and how sturdy-refs are promoted to objects when initiating a connection, I think we can have equivalent behavior by reserving a sturdyref for a bootstrap object when opening a captp connection.



### [#167](https://github.com/ocapn/ocapn/issues/167) Single op:deliver message type with resolution subscription via op:listen

Kumavis is absent, per Hawaiian time zone.

Kris: I see Kumavis has a concrete proposal. I'm going to take a closer look, but the gist as I understand:

We've discussed consolidating "deliver" and "deliver only", and I believe we've all remained on the fence on that. I think we've settled on it being incoherent (??!).

The aspect I'm interested in is making it possible to deliver without an implicit listen, so the remote side isn't obligated to deliver a large pass-on-copy data struct. With that, I hear Jessica has done some looking into this.

Jessica: Partly came up b/c I was implementing in Goblins and we had no "resolve me" descriptor, so I used listen, and that got me thinking about this. I spent the last week investigating and implementing Kumavis's proposal. Opened a PR in Goblins. Took a good bit of reworking for how we handle promises in Goblins, b/c it was assumed that promises were always eager (always interested in the answer), which if pipelining you might not be interested in.

A methaphor:  factory.makeMeCar().drive(). or ((factory makeCar) drive) In that case, you want the response, but the prior messages (intermediate), are only used for pipelining.

[missed some]
We would emit an op-listen. Register interest. Otherwise discard op:deliver-only, and it works really well. We've seen captp messages reduce in volume significantly with this change.

ri
Ridley
12:53 PM
does this proposal mean that any time you want a resulting value from a deliver, you also need to send a listen?

kr
Kris Kowal
12:53 PM
yes

ch
Christine Lemmer-Webber
12:53 PM
that's open for discussion. We could allow not requiring a follow up message when you know you want it. We could allow including a resolve-me descriptor and allowing it to be false, then you could drop the listen operator in those cases and result in one fewer messages being sent. Not sure that'd be a big win if we were compressing our protocol's symbol names or something.

Spritely found that in practice that Jessica's implementation resulted in a drop of traffic.

MarkM: Can someone define "lazy" in this conversation?

Christine: If I send a message. A sends a message to B, then immediately to the resulting object (the usual pipeline example). The question is if you don't need to hear the intermediate object. The lazy way is if you only request the value from the intermediate method by setting up a handler for it. A callback or handler for it.

MarkM: So the distinction is what's visible on Alice's side (the sending side). It's still the case that what's in this case called "lazy/eager" in both cases vat B (with Bob) does the same computation that came from sending him a message as he did if he sent a result to the previous message. The same computation happens, and the only difference is delaying the resolution of the promise held by vat A. Correct?

Christine: Not the resolution itself, but the returned result.

MarkM: I would not use the term lazy for that. Lazy in the actor context and others seems different, that the computation

Dan Finlay
12:59 PM
Not lazy, more... ignorant?

ba
Baldur
12:59 PM
long worded (eager) and shortworded (lazy)

da
Dan Finlay
1:00 PM
curious/ignorant vs eager/lazy

ba
Baldur
1:00 PM
Dan: that is more the term I was looking for

da
Dan Finlay
1:00 PM
one is for knowledge, the other is for timeliness

Christine: It's about when you have a customer who is interested in the result. (citing Carl Hewitt). Confusion noted, we will explore alternate terms.

Jessica: Regardless of naming, What I called not-eager promises by result reduces messages. If you always wanted the answer, you would always send "deliver" and then "listen". You could just neglect to send "listen" if you wanted. Mostly meant as an implementation report on Goblins. We could also keep the resolve-me descriptor and let the implementations that want to be "lazy" (since we have the term now) could. And those who want to be eager could continue to specify a resolve-me descriptor. I don't have a strong preference either way. Kumavis's proposal suggests removing it. I think we could keep it if we think this is a common use case that we want to support.

Kris: I believe the resolve-me descriptor goes away with the previous op:resolve and op:break, since those will operate in terms of answer numbers instead of resolve-me targets.

Jessica:  You would want to keep those around for promises sent in messages as arguments. Imagine Alice sends Bob a message that contains a resolver of some description. You would want to be able to resolve that on the other side.

Kris: So having a conventional resolver-target protocol for resolving remote promises? Yeah...  That is analogous to our CapTP sending a "resolve" function over CapTP, which we just don't do.. I don't think it needs to be specified in OcapN, but can be a convention.

Jessica: I'll consider more.

Kris: In any case, we haven't "settled" on this issue (har har), but we could resume working towards specification for a consensus for a future meeting.

Jessica: I think we're positive on the change, in summary.

Kris: Do you want to own the spec changes?

Jessica: Happy to.

JAR: Use the "assignee" feature.

### End of meeting

Kris: Closing remark: Thank you! We've had a great run of OcapN meetings these last months. Let's keep it going!

Jessica: I'd like to queue another topic: Checking a peer is the peer they say they are.






