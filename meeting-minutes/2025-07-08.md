# July 2025 OCapN pre-standardization meeting, 2025-07-08

## Attendees
- **Chair**: Jonathan Rees
- **Scribe**: David Thompson
- **Present**:
  - Kris Kowal (Endo/DCF/Agoric)
  - Baldur (independent)
  - Christine Lemmer Webber (Spritely)
  - Jessica Tallon (Spritely)
  - Rey Bengo
  - David Thompson (Spritely)
  - Jonathan Rees
  - Juli (Spritely)
  - Mark Miller (Endo/DCF/Agoric)
  - Richard Gibson (Agoric)
  - Ridley (independent, Dart)

## Agenda

- @tsyesika: I'd like to queue another topic: Checking a peer is the peer they say they are.
- @kriskowal, @RidleyWrites
  - [Reusability of passable data #172,](https://github.com/ocapn/ocapn/issues/172)
  - [Bug: no way to describe an imported answer promise over the wire #168](https://github.com/ocapn/ocapn/issues/168)
  - [Identifying promise and object references #101](https://github.com/ocapn/ocapn/issues/101)
- Progress report on as-needed-listen promises

## Minutes

(Chat: Jessica: Just an update, I added tests for op:get and op:index to the test suite.)

Jessica: I've been busy with other things, though originally wanted to cover dialback auth

jar: Additions or changes to the agenda?

Christine: A progress report on "lazy promises" or "as-needed-listen" in Goblins

Jessica: I had a working demo that greatly improved (reduced) the number of CapTP messages, but there ended up being some issues with promise chaining. They aren't necessarily issues that everyone would face, but they were issues for us and the work is sitting in a branch and are unlikely to be merged. There were hard to squish bugs. I think it's interesting to note that we knew it would add complications to know if you are eagerly listening to a promise or not and it indeed ended up being complex.

jar: What's the disposition on this?

Christine: It's an update from last month's meeting when we were more optimistic. We didn't update everything in our implementation because we ran into issues.

Jessica: It's technically doable, but it increases burden on implementors.

Baldur: This sounds like the detection of an 'on' operation.  It's a complication in the CapTP implementation but not the user API.

Jessica: It's about ordering and how promises chain and values propagate.

Christine: I wanted to temper the previous comment where last month we said we could do it and now we're not doing it.

jar: We will await your next status report, then?

Christine: Sure.

MarkM: On the terminology, we're all agreed that the computation provoked by an eventual send is eager. The question is then: does the protocol resolve, in the case you have a remote promise... is the side updating the local promise obligated to update the side with the remote promise wrt to eager eventual consistency? It's all a question of eventual consistency, is it prompt or does it wait for someone to ask? Depending on the specifics, we could call it "lazy promise settlement", "lazy promise fulfillment", "lazy promise resolution", or "lazy promise shortening". The only point that is dangerous, is that I would be strongly against lazy shortening and the reason isn't a performance concern. The reason is fragility under partition. If you have a long chain through different sites and you do lazy shortening, the problem is that until the shortening happens, if any intermediate site drops out then the entire distributed promise chain has been severed. If you do eager shorterning, which I think can be compatible with other forms of laziness, then you don't get fragility in perpetuity. Agoric doesn't do shortening yet, but I think we should obligate.

Christine: I like Kris' comment about "auto-listen" and Jessica's comment that we have had internal mixups about the things Mark is distinguishing.

Jar: Should we continue talking about this? (Was this in regards to dialback or the previous topic???)

Jessica: We should move on.

Jar: I'll hand this off to Kris then.

Kris: I would like to talk about issue 172. https://github.com/ocapn/ocapn/issues/172

Kris: The meat of this is that there are entangled design decisions about references in the body of a message, the passable data portion. Currently the passable data portion is inlined. The axes of the design decisions that are in play are... one of them is whether or not to distinguish local/remote for a position. The most germane thing of the reusability of passable data is there are situations where you want an OCapN implementation to act as a relay and be able to pass along the bytes without parsing them, but modify the clists and update reference ids. We are going to want to grant match on error, which means there is some in-band and out-of-band information about errors that make them unique, though error details are in flux. There are 3 levels of optimization that can be performed. We could capture the binary representation of the reusable portion of passable data as a bytearray so a relay could use the length to skip over it entirely or memcpy it to another location. We could distinguish or not distinguish on the type of slot: promise, error, etc. We could capture the rank order of the information for sorting. Entangled in this is the issue of how we represent individual objects and their clist positions. If they are broken down with a passable object with the data portion as a bytearray and respective arrays for the clist positions of targets, promises, and errors, with errors potentially having more metadata and thus wrapped in a record. I am proposing that we move in this direction. I've worked on hyper-optimized transport protocols and one useful thing is to be able to read bytes from one socket, make modifications in-place with no allocation, and then write them to another socket. To do this, we worked to make sure that data was at fixed offsets, or failing that, at a computable offset.  This may not be possible within the constraints of OCapN. But we could get to the point where the rewritable portion is separate from everything else. I don't think this is possible with Syrup but maybe with CBOR. I think this would be important for relays trying to relay 10k+ messages per second.

Baldur: This is to prevent us from painting ourselves into a corner at a later date, right? Even if you don't implement this speed-up, we wouldn't preclude it. We don't want a relay to have to rewrite every message. I'm all for it as long as we're not binding ourselves to any single binary format at this time.

Kris: The status with Agoric's CapTP and smallcaps is that we do separate body and slots, which puts us a little ahead of the game, but since it's not a binary format many of the advantages are moot. We do a lot of relaying currently and we have to parse JSON to rewrite messages. It would be ideal to be able to make these optimizations possible.

Christine: I'm a bit lost, and so is Jessica. I'm having trouble understanding the particular goals here. Is this related to Agoric using CapTP internally to communicate between vats. I think I need to understand the motivation better.

Kris: SwingSet implements a CapTP called Live Slots. It's not our only CapTP. We have others. In all of these cases, there will be places where there is a need for relays. We need to leave the door open for relays to perform with high throughput at low cost.

Christine: We are working towards a relay that is end-to-end encrypted. The relay you are describing would need to be privy to the contents?

Kris: That's correct.  Agoric has cases where it's okay for relays to be privy to the message contents.  The topology we have at the moment for inter-vat communication is that there are tables that are framed by vat id and slot number and sees the entire universe that way, but then there's the comms vat that sees the world by the public keys of all its peers. Both are in a position where they do not need to see the body of a message, but they need to see the envelope.

Jessica: Can I clarify my understanding? My thinking is that this is similar to file descriptors where each vat would know each object by a different number, so the kernel might want to rewrite import object 2 to import object 10. You want to enable the kernel to do this rewriting without parsing the rest of the CapTP message.

Kris: Correct, and our implementation does this currently, though it's JSON within JSON rather than binary.

Jessica: I think I need to go back and re-read this and talk with the rest of Spritely to understand how it would affect the rest of CapTP.

Kris: There are very few places in OCapN's CapTP where passable data gets expressed in a passable message. It's in fulfillment notifications and some others. Those are really the only touch points and there are some concrete ways to do it. One way this design could be folded into the spec is to simply alter... let's take op:deliver as a specific case. The args array would be replaced with either a bytearray of the data portion of the message with interpolated slots and then have additional fields on the op:deliver message to map clist entries to those interpolated slots. The other is to (dave missed this one, sorry). I'd like to go even farther where the message itself is structured in a way, if we were using CBOR, that the message is a tuple and the final entry of the tuple has all this interpolated data as a suffix. It would require allocation that would be amortized as a process arrives at a maximum message width.

Jessica: It sounds like you would read all of op:deliver and then rewrite just the args?

Kris: Not exactly. Within op:deliver there are args and I'm suggesting the immutable portion be represented inline. Ideally we want to be able to read from an ingress socket, hopefully avoiding resizing the buffer we put it in, and performing minimal processing of the data in the buffer before we send it out the egress socket.

Jessica: I think I understand. Would you also need the receiver description and answer position to be slots?

Baldur: I don't think so.

Kris: I think the answer is "probably yes".

Jessica: I had also assumed yes. I think this would also come up in the gc and other delivery operators.

Kris: For Agoric we have this generalized data structure everywhere, where the body is a JSON-parseable string, and then there are slots separately.

Richard Gibson: The important thing here is that there's a layer of indirection to support efficient relaying and that it is a suffix rather than an embedding or (something else Dave missed). CBOR has an advantage to Syrup here, but it can still be done with Syrup.

Kris: I think I'm satisfied that I have communicated my intention of the design and that the Spritely folks will want to talk about it amongst themselves. I consider this topic concluded for now.

jar: I thought that was pretty interesting. Looking at the agenda, Jessica has some time if she wants, otherwise we should adjourn.

Jessica: I can briefly, instead of touching on dialback, I can say I briefly had a look at desc:import-answer and it occurred to me that I think it would run into some GC issues. I left it today so I assume no one had time to look at it. The way the current draft spec is writter, the sender is always in control of the answer position and knowing when it goes out of scope. Since the other side never references it, the sender has an easy time GCing it. If you allow the other side to reference this, it would cause GC problems. I think Goblins doesn't run into this because it doesn't reference this by its answer position but by a desc:import-object. Something to think about.

jar: Any more specific requests of people or next steps?

Jessica: I left a comment on the issue and it could be discussed there or in a future meeting.

Kris: Thank you for looking into it. I don't understand, but I believe you. Let's continue the conversation out-of-band on the issue. Is it possible that the GC is as simple as that there's an obligation to release or is there a race condition?

Jessica: The issue is that since only the sender currently references the answer position, it knows when to issue the op:gc-answer. You run into issues regarding not knowing if it can be GC'd if both sides can reference it.

Kris: So we'd be in a situation where both sides would have to agree that it can be released before it can be released?

Jessica: Yes, I think that's true. The current GC strategy would be invalidated by introducing this possibility.

Kris: Okay, I'll continue on the issue. I think I have enough to go on.

jar: Anything else?

Kris: Does anyone have any topics for next month?

Jessica: We at Spritely have been talking about "permiter types", basically protocol extensions for unspecified types and round tripping them. I'm going to write up an issue explaining this.

MarkM: Is this an issue about using tagged? Because at Agoric we are using this extensively and are very happy with it.

Jessica: We also use tagged for this, but we also expose tags to userspace. We are trying to figure out if we need multiple layers of tagged types.

Kris: I think Agoric might be in the position where we want one layer but have two in practice.

MarkM: We don't have two. There's a separation between tags and the layer above them.

Kris: (Dave missed this question)

MarkM: It's possible to make tags that are incomprehensible to each other, but there is some awkwardness.

Kris: We should discuss this next month.
